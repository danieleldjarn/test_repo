"""
Europeana Search API Client Library

A Python client for interacting with the Europeana Search API.
Provides a clean interface for searching cultural heritage items with support
for complex queries, faceting, and pagination.
"""

import copy
import time
from typing import Dict, List, Optional, Iterator, Union
from dataclasses import dataclass
from enum import Enum
import httpx


# Field Constants
class SearchFields:
    """Aggregated search fields that search across multiple metadata fields."""

    TITLE = "title"  # Searches all title fields
    WHO = "who"  # Creator/contributor names
    WHAT = "what"  # Subject/topic/type
    WHEN = "when"  # Dates/time periods
    WHERE = "where"  # Geographic locations


class ProxyFields:
    """Provider proxy fields - original metadata from contributing institutions."""

    DC_CREATOR = "proxy_dc_creator"  # Creator/artist name
    DC_TITLE = "proxy_dc_title"  # Original title
    DC_SUBJECT = "proxy_dc_subject"  # Subject keywords
    DC_TYPE = "proxy_dc_type"  # Object type (painting, sculpture, etc.)
    DC_FORMAT = "proxy_dc_format"  # Physical/digital format
    DC_RIGHTS = "proxy_dc_rights"  # Rights information
    DC_LANGUAGE = "proxy_dc_language"  # Language code (e.g., 'nl', 'en')
    DC_DESCRIPTION = "proxy_dc_description"  # Description
    DC_DATE = "proxy_dc_date"  # Date information
    DC_PUBLISHER = "proxy_dc_publisher"  # Publisher
    DC_CONTRIBUTOR = "proxy_dc_contributor"  # Contributors
    DC_IDENTIFIER = "proxy_dc_identifier"  # Identifier
    DC_RELATION = "proxy_dc_relation"  # Related resources
    DC_SOURCE = "proxy_dc_source"  # Source of the resource
    DC_COVERAGE = "proxy_dc_coverage"  # Spatial or temporal coverage
    DCTERMS_SPATIAL = "proxy_dcterms_spatial"  # Geographic location
    DCTERMS_TEMPORAL = "proxy_dcterms_temporal"  # Time period
    DCTERMS_MEDIUM = "proxy_dcterms_medium"  # Material/medium (oil, canvas, etc.)
    DCTERMS_CREATED = "proxy_dcterms_created"  # Creation date
    DCTERMS_ISSUED = "proxy_dcterms_issued"  # Issue date
    DCTERMS_EXTENT = "proxy_dcterms_extent"  # Size or duration
    DCTERMS_ALTERNATIVE = "proxy_dcterms_alternative"  # Alternative title


class EuropeanaFields:
    """Europeana administrative fields - metadata generated by Europeana."""

    YEAR = "europeana_year"  # Normalized year (supports range queries)
    COMPLETENESS = "europeana_completeness"  # Metadata quality score (0-10)


class EDMFields:
    """Europeana Data Model (EDM) fields - core structural metadata."""

    TYPE = "edm:type"  # EDM type (not same as media type)
    DATA_PROVIDER = "edm:dataProvider"  # Contributing institution
    PROVIDER = "edm:provider"  # Aggregator organization
    RIGHTS = "edm:rights"  # Standardized rights URI
    CURRENT_LOCATION = "edm:currentLocation"  # Current physical location
    IS_SHOWN_BY = "edm:isShownBy"  # Primary digital representation URL
    IS_SHOWN_AT = "edm:isShownAt"  # Web page with item context
    OBJECT = "edm:object"  # URL of object representation
    HAS_VIEW = "edm:hasView"  # Additional views
    AGGREGATED_CHO = "edm:aggregatedCHO"  # Cultural Heritage Object reference


class FilterFields:
    """Special filter fields for common filtering operations."""

    TYPE = "TYPE"  # Media type filter (IMAGE, SOUND, VIDEO, TEXT, 3D)
    PROVIDER = "PROVIDER"  # Provider/aggregator filter
    DATA_PROVIDER = "DATA_PROVIDER"  # Data provider/institution filter
    RIGHTS = "RIGHTS"  # Rights filter (supports wildcards)
    YEAR = "YEAR"  # Year filter
    COUNTRY = "COUNTRY"  # Country filter
    LANGUAGE = "LANGUAGE"  # Language filter
    REUSABILITY = "reusability"  # Reusability filter (open, restricted, permission)
    MEDIA = "media"  # Has media flag
    THUMBNAIL = "thumbnail"  # Has thumbnail flag
    LANDINGPAGE = "landingpage"  # Has landing page flag
    TEXT_FULLTEXT = "text_fulltext"  # Full text search
    MIME_TYPE = "MIME_TYPE"  # MIME type filter


# Enums
class MediaType(Enum):
    """Available media types for filtering."""

    IMAGE = "IMAGE"
    SOUND = "SOUND"
    VIDEO = "VIDEO"
    TEXT = "TEXT"
    THREE_D = "3D"


class Profile(Enum):
    """Response detail levels."""

    MINIMAL = "minimal"  # Basic metadata only
    STANDARD = "standard"  # Standard metadata
    RICH = "rich"  # Full metadata including all available fields
    FACETS = "facets"  # Include facet counts in response


class Reusability(Enum):
    """Content reusability categories."""

    OPEN = "open"  # Freely reusable content
    RESTRICTED = "restricted"  # Content with some restrictions
    PERMISSION = "permission"  # Requires explicit permission


class RightsCategories:
    """Common rights patterns and URIs for filtering."""

    # Patterns for wildcard searches
    PUBLIC_DOMAIN = "*public*"
    CREATIVE_COMMONS = "*creative*"
    COPYRIGHT = "*copyright*"

    # Public Domain URIs
    PDM_URI = "http://creativecommons.org/publicdomain/mark/1.0/"
    CC0_URI = "http://creativecommons.org/publicdomain/zero/1.0/"

    # Creative Commons License URIs (version agnostic patterns)
    CC_BY = "http://creativecommons.org/licenses/by/*"
    CC_BY_SA = "http://creativecommons.org/licenses/by-sa/*"
    CC_BY_ND = "http://creativecommons.org/licenses/by-nd/*"
    CC_BY_NC = "http://creativecommons.org/licenses/by-nc/*"
    CC_BY_NC_SA = "http://creativecommons.org/licenses/by-nc-sa/*"
    CC_BY_NC_ND = "http://creativecommons.org/licenses/by-nc-nd/*"

    # Rights Statements URIs
    IN_COPYRIGHT = "http://rightsstatements.org/vocab/InC/1.0/"
    IN_COPYRIGHT_EU_ORPHAN = "http://rightsstatements.org/vocab/InC-OW-EU/1.0/"
    IN_COPYRIGHT_EDUCATIONAL = "http://rightsstatements.org/vocab/InC-EDU/1.0/"
    IN_COPYRIGHT_NON_COMMERCIAL = "http://rightsstatements.org/vocab/InC-NC/1.0/"
    NO_COPYRIGHT_CONTRACTUAL = "http://rightsstatements.org/vocab/NoC-CR/1.0/"
    NO_COPYRIGHT_OTHER = "http://rightsstatements.org/vocab/NoC-OKLR/1.0/"
    NO_KNOWN_COPYRIGHT = "http://rightsstatements.org/vocab/NKC/1.0/"
    COPYRIGHT_NOT_EVALUATED = "http://rightsstatements.org/vocab/CNE/1.0/"
    COPYRIGHT_UNDETERMINED = "http://rightsstatements.org/vocab/UND/1.0/"


# Facetable fields list
FACETABLE_FIELDS = [
    ProxyFields.DC_CREATOR,
    ProxyFields.DC_CONTRIBUTOR,
    ProxyFields.DC_SUBJECT,
    ProxyFields.DC_TYPE,
    ProxyFields.DC_RIGHTS,
    ProxyFields.DCTERMS_MEDIUM,
    ProxyFields.DCTERMS_SPATIAL,
    FilterFields.TYPE,
    FilterFields.PROVIDER,
    FilterFields.DATA_PROVIDER,
    FilterFields.RIGHTS,
    FilterFields.COUNTRY,
    FilterFields.LANGUAGE,
]


# Module-level constants
DEFAULT_ROWS = 100
MAX_ROWS = 100


def build_query_string(
    text: Optional[str] = None,
    filters: Optional[Dict[str, Union[str, Enum]]] = None,
) -> str:
    """
    Build a Lucene query string from text and filters.

    Args:
        text: Free text search query
        filters: Dictionary of field:value filters (values can be strings or enums)

    Returns:
        Combined query string
    """
    query_parts = []

    # Add free text if provided
    if text:
        query_parts.append(text)

    # Add filters
    if filters:
        for field, value in filters.items():
            # Handle enum values
            if hasattr(value, "value"):  # Check if it's an enum
                value = value.value

            # Convert to string if not already
            value = str(value)

            # Handle special fields that might need quotes
            if " " in value and not (value.startswith('"') and value.endswith('"')):
                value = f'"{value}"'
            query_parts.append(f"{field}:{value}")

    # Combine with AND
    return " AND ".join(query_parts) if query_parts else ""


@dataclass
class SearchResults:
    """Container for Europeana search results with pagination info."""

    items: List[Dict]
    total_results: int
    next_cursor: Optional[str] = None
    facets: Optional[Dict] = None
    query: Optional[str] = None

    def __len__(self) -> int:
        """Return the number of items in this result set."""
        return len(self.items)

    def __iter__(self) -> Iterator[Dict]:
        """Iterate over items in the result set."""
        return iter(self.items)


class QueryBuilder:
    """Fluent interface for building Europeana search queries."""

    def __init__(self):
        """Initialize QueryBuilder."""
        self._filters = {}
        self._text_query = None
        self._geographic = None
        self._facets = []
        self._profile = Profile.RICH
        self._rows = DEFAULT_ROWS
        self._reusability = None
        self._media_flag = None
        self._thumbnail_flag = None

    def creator(self, name: str) -> "QueryBuilder":
        """Add creator/artist filter."""
        self._filters[SearchFields.WHO] = name
        return self

    def location(self, place: str) -> "QueryBuilder":
        """Add geographic location filter."""
        self._filters[SearchFields.WHERE] = place
        return self

    def subject(self, topic: str) -> "QueryBuilder":
        """Add subject/topic filter."""
        self._filters[SearchFields.WHAT] = topic
        return self

    def title(self, title: str) -> "QueryBuilder":
        """Add title filter."""
        self._filters[SearchFields.TITLE] = title
        return self

    def when(self, time_description: str) -> "QueryBuilder":
        """Add temporal description filter."""
        self._filters[SearchFields.WHEN] = time_description
        return self

    def media_type(self, media_type: Union[str, MediaType]) -> "QueryBuilder":
        """Add media type filter."""
        if isinstance(media_type, MediaType):
            media_type = media_type.value
        self._filters[FilterFields.TYPE] = media_type
        return self

    def time_period(
        self, start_year: Optional[int] = None, end_year: Optional[int] = None
    ) -> "QueryBuilder":
        """Add time period filter with year range."""
        if start_year and end_year:
            self._filters[EuropeanaFields.YEAR] = f"[{start_year} TO {end_year}]"
        elif start_year:
            self._filters[EuropeanaFields.YEAR] = f"[{start_year} TO *]"
        elif end_year:
            self._filters[EuropeanaFields.YEAR] = f"[* TO {end_year}]"
        return self

    def public_domain(self) -> "QueryBuilder":
        """Filter for public domain items only."""
        self._filters[FilterFields.RIGHTS] = (
            f"({RightsCategories.PDM_URI} OR {RightsCategories.CC0_URI})"
        )
        self._reusability = Reusability.OPEN
        return self

    def creative_commons(self, license_type: Optional[str] = None) -> "QueryBuilder":
        """Filter for Creative Commons licensed items."""
        if license_type:
            license_map = {
                "by": RightsCategories.CC_BY,
                "by-sa": RightsCategories.CC_BY_SA,
                "by-nd": RightsCategories.CC_BY_ND,
                "by-nc": RightsCategories.CC_BY_NC,
                "by-nc-sa": RightsCategories.CC_BY_NC_SA,
                "by-nc-nd": RightsCategories.CC_BY_NC_ND,
            }
            rights_filter = license_map.get(
                license_type.lower(), RightsCategories.CREATIVE_COMMONS
            )
        else:
            rights_filter = RightsCategories.CREATIVE_COMMONS
        self._filters[FilterFields.RIGHTS] = rights_filter
        return self

    def institution(self, name: str, as_provider: bool = False) -> "QueryBuilder":
        """Filter by contributing institution."""
        field = FilterFields.PROVIDER if as_provider else FilterFields.DATA_PROVIDER
        self._filters[field] = name
        return self

    def quality(self, min_score: int = 8) -> "QueryBuilder":
        """Filter by metadata quality score (0-10)."""
        self._filters[EuropeanaFields.COMPLETENESS] = f"[{min_score} TO 10]"
        return self

    def field(self, field_name: str, value: str) -> "QueryBuilder":
        """Add generic field filter."""
        self._filters[field_name] = value
        return self

    def text(self, query: str) -> "QueryBuilder":
        """Add free text search query."""
        self._text_query = query
        return self

    def geographic(self, lat: float, lon: float, radius_km: float) -> "QueryBuilder":
        """Add geographic proximity search."""
        self._geographic = (lat, lon, radius_km)
        return self

    def facets(self, *field_names: str) -> "QueryBuilder":
        """Add facet fields for aggregated results."""
        self._facets.extend(field_names)
        return self

    def profile(self, profile: Union[str, Profile]) -> "QueryBuilder":
        """Set response detail level."""
        self._profile = profile
        return self

    def rows(self, count: int) -> "QueryBuilder":
        """Set number of results per page."""
        self._rows = min(count, MAX_ROWS)
        return self

    def reusability(self, level: Union[str, Reusability]) -> "QueryBuilder":
        """Set reusability filter."""
        self._reusability = level
        return self

    def with_media(self, has_media: bool = True) -> "QueryBuilder":
        """Filter items with/without media."""
        self._media_flag = has_media
        return self

    def with_thumbnails(self, has_thumbnails: bool = True) -> "QueryBuilder":
        """Filter items with/without thumbnails."""
        self._thumbnail_flag = has_thumbnails
        return self

    def get_query_string(self) -> str:
        """Generate and return the Lucene query string."""
        return build_query_string(self._text_query, self._filters)

    def __repr__(self) -> str:
        """String representation for debugging."""
        parts = []
        if self._text_query:
            parts.append(f"text='{self._text_query}'")
        if self._filters:
            filter_strs = [f"{k}:{v}" for k, v in self._filters.items()]
            parts.append(f"filters=[{', '.join(filter_strs)}]")
        if self._geographic:
            lat, lon, radius = self._geographic
            parts.append(f"geographic=({lat}, {lon}, {radius}km)")
        return f"QueryBuilder({', '.join(parts)})"


class EuropeanaClient:
    """Client for interacting with the Europeana Search API."""

    DEFAULT_BASE_URL = "https://api.europeana.eu/record/v2/search.json"

    def __init__(self, api_key: str, base_url: Optional[str] = None):
        """
        Initialize the Europeana client.

        Args:
            api_key: Your Europeana API key
            base_url: Optional custom base URL for the API
        """
        self.api_key = api_key
        self.base_url = base_url or self.DEFAULT_BASE_URL
        self._client = httpx.Client(timeout=30.0)

    def __enter__(self):
        """Context manager entry."""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit - close HTTP client."""
        self.close()

    def close(self):
        """Close the HTTP client."""
        self._client.close()

    def search(
        self,
        query: QueryBuilder,
        cursor: str = "*",
        **kwargs,
    ) -> SearchResults:
        """
        Perform a search on the Europeana API.

        Args:
            query: QueryBuilder object with search parameters
            cursor: Pagination cursor (use "*" for first page)
            **kwargs: Additional query parameters to override

        Returns:
            SearchResults object containing items and pagination info
        """
        # Get query string from QueryBuilder
        query_str = query.get_query_string()

        # Extract parameters from QueryBuilder
        rows = query._rows
        facets = query._facets if query._facets else None
        profile = query._profile
        geographic = query._geographic
        reusability = query._reusability
        media = query._media_flag
        thumbnail = query._thumbnail_flag

        # Handle enum values
        if isinstance(profile, Profile):
            profile = profile.value
        if isinstance(reusability, Reusability):
            reusability = reusability.value

        # Prepare parameters
        params = {
            "query": query_str or "*:*",
            "rows": str(min(rows, MAX_ROWS)),
            "cursor": cursor,
            "wskey": self.api_key,
            "profile": profile,
        }

        # Add facets if requested
        if facets:
            params["facet"] = ",".join(facets)

        # Add geographic filter if provided
        if geographic:
            lat, lon, radius = geographic
            params["qf"] = f"distance(coverageLocation,{lat},{lon},{radius})"

        # Add reusability filter
        if reusability:
            params["reusability"] = reusability

        # Add media filters
        if media is not None:
            params["media"] = str(media).lower()
        if thumbnail is not None:
            params["thumbnail"] = str(thumbnail).lower()

        # Add any additional parameters
        params.update(kwargs)

        # Make the request
        response = self._client.get(self.base_url, params=params)
        response.raise_for_status()
        data = response.json()

        # Extract results
        return SearchResults(
            items=data.get("items", []),
            total_results=data.get("totalResults", 0),
            next_cursor=data.get("nextCursor"),
            facets=data.get("facets", []) if facets else None,
            query=query_str,
        )

    def search_all(
        self,
        query: QueryBuilder,
        max_records: Optional[int] = None,
        delay: float = 0.1,
    ) -> Iterator[Dict]:
        """
        Iterator that fetches all results for a query using pagination.

        Args:
            query: QueryBuilder object with search parameters
            max_records: Maximum number of records to fetch (None for all)
            delay: Delay between requests in seconds (courtesy to API)

        Yields:
            Individual items from all result pages
        """
        cursor = "*"
        records_fetched = 0

        while True:
            # Calculate rows for this request
            if max_records:
                remaining = max_records - records_fetched
                if remaining <= 0:
                    break
                rows = min(DEFAULT_ROWS, remaining)
            else:
                rows = DEFAULT_ROWS

            # Create a copy of the query with the current page size
            page_query = copy.deepcopy(query)
            page_query._rows = rows

            # Fetch a page of results
            results = self.search(page_query, cursor=cursor)

            # Yield items from this page
            for item in results.items:
                yield item
                records_fetched += 1
                if max_records and records_fetched >= max_records:
                    return

            # Check if there are more pages
            if not results.next_cursor or len(results.items) == 0:
                break

            cursor = results.next_cursor

            # Courtesy delay between requests
            time.sleep(delay)

    def query(self) -> QueryBuilder:
        """Create a new QueryBuilder for fluent query construction."""
        return QueryBuilder()
